# 练习：循环与函数

为了练习函数与循环，我们来实现一个平方根函数：给定一个数 x，我们需要找到一个数 z 使得 z² 尽可能地接近 x。

计算机通常使用循环来计算 x 的平方根。从某个猜测的值 z 开始，我们可以根据 z² 与 x 的近似度来改进 z，产生一个更好的猜测：

https://tour.go-zh.org/flowcontrol/8

```js
z -= (z*z - x) / (2*z)
```
重复调整的过程，猜测的结果会越来越精确，得到的答案也会尽可能接近实际的平方根。

请在提供的 func Sqrt 中实现它。无论输入是什么，可以先猜测 z 为 1。 首先，重复计算 10 次并连续打印每次的 z 值。观察对于不同的 x 值（1、2、3 ...）， 你得到的答案是如何逼近结果的，以及猜测改进的速度有多快。

提示：用类型转换或浮点数语法来声明并初始化一个浮点数值：

```js
z := 1.0
z := float64(1)
```

然后，修改循环条件，使得当值停止改变（或改变非常小）的时候退出循环。 观察迭代次数大于还是小于 10。尝试改变 z 的初始猜测，如 x 或 x/2。 你的函数结果与标准库中的 math.Sqrt 有多接近？

（ 注： 如果你对该算法的细节感兴趣，上面的 z² − x 是 z² 到它所要到达的值（即 x） 的距离，除数 2z 为 z² 的导数，我们通过 z² 的变化速度来改变 z 的调整量。 这种通用方法叫做牛顿法， 它对很多函数，特别是平方根而言非常有效。）

```js
package main

import (
    "fmt"
    "math"
)

func Sqrt(x float64) float64 {
    z := 1.0
    // 先进行10次迭代
    for i := 0; i < 10; i++ {
        z -= (z*z - x) / (2*z)
        fmt.Printf("第 %d 次迭代，z 的值为: %f\n", i+1, z)
    }

    // 修改循环条件，当值变化很小时退出循环
    prevZ := z
    for {
        z -= (z*z - x) / (2*z)
        if math.Abs(z-prevZ) < 0.000001 {
            break
        }
        prevZ = z
    }
    return z
}

func main() {
    fmt.Printf("自己实现的 Sqrt(2) 的结果: %f\n", Sqrt(2))
    fmt.Printf("标准库中 math.Sqrt(2) 的结果: %f\n", math.Sqrt(2))
}
```

